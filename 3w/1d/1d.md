### 1d

CPU 코어가 ALU여? -> 코어마다 하나씩? 하긴

범용 레지스터 R0-12: 걍 변수 값 불러다가 담음. ALU는 이쪽 범용 레지스터만 접근 가능 -> 이후 스택에 저장?
R13: stack pointer - 
R14: linker register
R15: Program Counter

SDRAM
.text(?): 코드
R/o: 상수(리터럴), 
R/w: 전역변수, static, bss 영역(초기화되면서 전역변수 잡히는? 초기화안됐다고? 안된거인듯?)
Heap: malloc(동적)
Stack: 지역변수

자료형싸이즈
CPU 데이터버스가 (32비트기준) 0-31. = 8비트.
int는 그 길이를 따라감 (보통은). 그래서 4바이트 / 포인터도 주소덕에 4바이트

포인터: 그냥주소가아니다! 값으로 주소와 크기를 가짐
Ex: [0]의 주소만 가리키고 거기부터 +4까지의 크기를 가리킴.
배열이 떠오르지만 int도 byte단위라는 걸 생각하면 비슷함
이 때의 “크기”가 바로 자료형. (뇌피셜: 혹은 해석 방법 명시)

pull(?) descending: 변수넣을때 주소가 하강? D[0]부터 채운다는 뜻인 듯
"시작 주소"를 결정하는 부분이라 포인터와 관련있음
...라기보다는
ch를 97번지에 저장하고 곧바로 short sh를 저장: 88번지로 descend한다

    D3 D2 D1 D0
    점 찍은 게 시작주소
    -  -  -  -  대충 메모리를 표현 하나당 4바이트(32bit)

    3  2  1  0. char[10]
    7  6  5  4  4의 배수 단위로 메모리를 채움
    -  -  9  8  

    3  2  1  0. double
    7  6  5  4  위쪽이 시작주소

    3  2  1  0. float

    3  2  1  0. long int
    7  6  5  4  당연히 아래부터 올라갈 줄 알았는데요

    3  2  1  0. int

    -  -  1  0. short 

    -  -  -  0. char


char는 메모리에서 C표준/C++ 컴파일러에 따라 메모리 적재 순서가 다름
난 D[3]에서 D[0]으로 내려가는 거만 알면 될 듯?

리틀엔디안: 데이터를 저장하는 방법
